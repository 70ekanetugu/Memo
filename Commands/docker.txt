■基本フロー
[構築1 : Dockerfileからコンテナを作る]*******************************************************
1)プロジェクト(ディレクトリ)作成し、カレントディレクトリにする。
2)ベースイメージをダウンロード
  $docker pull イメージ名[:タグ名]
     =>タグはバージョンみたいなもの(作成者が自由につけられる)。タグを指定しなければlatestになる。
2)Dockerfileの作成・・・コンテナの構成情報を定義したファイル。
  ・FROM:ベースとするイメージを指定。
　・WORKDIR:コンテナアタッチ後のカレントディレクトリ名を指定
  ・CMD["指定"] : 
3)イメージの作成　
   $docker build -t イメージ名 ディレクトリ名	
     =>Dockerfileを元にイメージを生成。イメージ名は指定できる。
4)コンテナの生成
   $docker create イメージ名 --name [コンテナ別名]
     =>イメージを元にコンテナを生成する。オプション--nameでコンテナに名前をつけられる。

 ※$docker run -it --name コンテナ名　
     =>コンテナの起動もまとめて行う場合は、runを使用する。
       -itオプションで、a

[構築2 : ベースイメージをそのまま利用]---------------------------------------------------------------
$docker pull イメージ名[:タグ名]	=>リモートリポジトリからDockerイメージを入手
$docker images ls			=>ローカルのイメージ一覧を確認
$docker images inspect イメージ名	=>イメージの詳細を表示
$docker run -it --name コンテナ名 -p 127.0.0.1:8080:3030 -v host側ﾊﾟｽ:ｺﾝﾃﾅ側ﾊﾟｽ	イメージ名
					=>コマンドラインで操作できるコンテナを作成&起動。
					　ポートフォワードも忘れずに。

[生成してあるコンテナを実行]--------------------------------------------------------------------------
$docker start コンテナ名
$docker exec -it コンテナ名 "/bin/bash"


■コマンド一覧
[Docker管理コマンド]--------------------------------------------------------------------------------
$dockerd [オプション]
	=>Dockerコンテナを管理するDockerデーモン(サービス)の起動。
	Dockerはデーモンとクライアントで異なるバイナリを使うらしい。
	外部とやり取りさせる場合は、色々設定必要そう...

$docker inspect [オプション] コンテナ|イメージ|タスク[コンテナ|イメージ|タスク...]
	=>コンテナorイメージorタスクの低レベル情報をJSONで表示。
	要はコンテナの設定、詳細情報をJSON形式で表示する。なお、フォーマット指定も可。

$docker version [オプション]
	=>dockerのバージョン取得。
	<オプション>
	-f,--format=""	指定するgoテンプレートを使い、出力を整形。(text/templateパッケージ参照)
	--help		使い方表示
	-t				
	他大量...

$docker images [オプション] [レポジトリ名]
	=>イメージの一覧表示。

$docker ps [オプション]
	=>稼働中のコンテナを一覧表示。
	[オプション]
	-a:すべてのコンテナ

$docker kill [オプション] コンテナ [コンテナ...]
	=>実行中のコンテナをSIGKILLか、指定したシグナルで停止
	<オプション>
	-s,--signal="KILL"	コンテナに送信するシグナル。
				コンテナ中のメイン・プロセス(PID1)に対してシグナルを送る

[イメージの作成他コマンド]------------------------------------------------------------------------------------------
$docker rmi イメージ名
	=>イメージの削除

$docker build -t [生成するイメージ名][:タグ名] [Dockerファイルのパス]


[コンテナ作成・起動・停止で使うコマンド]----------------------------------------------------------------------------
$docker rm [オプション] コンテナ [コンテナ....]
	=>1つ又は複数のコンテナを削除。不要なコンテナは定期的に削除する。

$docker rename 古い名前 新しい名前
	=>コンテナの名前を変更

$docker create イメージ名　[オプション] [コンテナ別名]
	=>イメージを元にコンテナを生成する。
	[オプション]
	--name : コンテナの別名を指定。

$docker run [実行オプション] [ネットワークオプション] --name コンテナ名　[生成オプション] イメージ名[:タグ名] [引数]
	=>コンテナ名と元のイメージを指定して、コンテナを起動する。
	　コンテナ実行のオプション、イメージのオプション、引数などオプションが多い。
	　[実行オプション]
	    -it:コンソールに結果を出すオプション
	    -d :コンテナを生成し、バックグランドで実行する。
	  [ネットワークオプション]
	    --add-host=[ホスト名:IPアドレス] : コンテナの/etc/hostsにホスト名、IPアドレスを定義する。	
	    --dns=[IPアドレス] : コンテナ用のDNSサーバのIPアドレス指定
	    --expose :指定したレンジのポート番号を割り当てる。
	    --mac-address=[MACアドレス] : コンテナのMACアドレスを指定する。
	    -p [hostポート:コンテナポート] : ホストとコンテナのポートマッピング。
	  [生成オプション]
	    -p : ポートフォワード指定。後ろに"hostアドレス:hostポート:ゲストポート"を各
	  [引数]
	    コンテナで実行するプロセスコマンドを書く。ターミナル起動を書くことが多い?("/bin/bash"みたいな)
	
$docker start [オプション] コンテナID
	=>コンテナを起動する。
	<オプション>
	-a	コンテナを起動してログインする。(attachする)

$docker stop [オプション] コンテナID
	=>コンテナを停止する。

$docker restart	[オプション] コンテナID
	=>コンテナを再起動する。

$docker exec [オプション]　コンテナ　コマンド [引数]
	=>実行中のコンテナでプロセスを実行する。コンテナの実行後であれば実行できる。
	 例えば、バックグランドで実行しているコンテナで、別のプロセスを実行させたい時、使う。
	※attachでログインすればと思うが、shellが起動していなければログインできない為。
	<オプション>
	-d	"コマンド"をバックグラウンドで実行
	-i	アタッチしてなくてもSTDINをオープンし続ける
	-t	疑似ターミナル(pseudo-TTY)の割り当て
	-u	ユーザー名を指定	

$docker attach コンテナID
	=>起動中のコンテナにログインする。*シェルが起動している必要がある。
docker
$docker top コンテナ名
	=>稼動コンテナで実行中のプロセス一覧を表示する。

$docker port コンテナ名
	=>稼動コンテナで実行されているプロセスが転送されているポートマッピングを表示する。
	ex."hostポート -> コンテナポート"

$docker cp コンテナ名:コンテナ内のファイルパス ホストのディレクトリパス
	=>コンテナ内のファイルをホスト側にコピーできる。(コンテナ->ホスト)
	
$docker cp ホストのファイル コンテナの識別子:コンテナのファイルパス
	=>前記の逆パターン。ホスト→コンテナへのコピー。


[Hub/レジストリ用コマンド]---------------------------------------------------------------------------
$docker pull [オプション] イメージ名[:タグ]|[レジストリ・ホスト[:レジストリ・ポート]/名前[:タグ]
	=>レジストリからイメージやリポジトリを取得する。
	"$docker pull イメージ名"で実行した場合、レジストリはDockerHubがデフォルトで指定される。
	プロキシ経由で利用する場合は、Dockerデーモンの設定(環境変数の設定)が必要。詳細はggr

$docker push [オプション] 名前[:タグ]
	=>イメージやリポジトリをレジストリに送信する。

$docker search [オプション] 単語
	=>DockerHubのイメージを検索
	

[ネットワーク接続用コマンド]------------------------------------------------------------------------
$docker network connect [オプション]　ネットワーク　コンテナ
	=>コンテナをネットワークに接続

[共有データ・ボリューム用コマンド]------------------------------------------------------------------
$docker volume create [オプション]
	=>ボリュームを作成。コンテナが利用し、データを保管するディレクトリ。
	オプションで名前指定しなければランダムな名前が付けられる。
	<オプション>
	--name=ボリューム名	ボリューム名を指定
	-d,--driver=local	ボリューム/ドライバ名を指定
$docker volume ls
	=>ボリュームの一覧



******************************************************************************************************
■用語・その他
・Dockerfile : インフラ構成情報を記述するファイル。これを各環境で使って同じ環境を構築できる
・Immutable Infrastructure:現在のインフラ状態を管理すること。⇔オンプレミスでは変更管理をしていた。
[インフラ構成ツール]
1)OSの起動を自動化するツール(Bootstrapping) ex.Vagrantなど
　・OSインストール
　・仮想環境の設定
　・ネットワーク構成の設定
2)OSやミドルウェアの設定を自動化するツール(Configuration)
　=>ミドルウェアのバージョン管理や、Linuxでいう/etc配下の設定ファイル、ファイアーウォール機能の設定
　　などセキュリティに関する設定を自動化する。
　・OSの設定(セキュリティ/サービスなど)
　・ミドルウェアのインストール/設定
3)複数サーバの管理を自動化するツール
　=>複数コンテナの管理を行うためのツール。
　・アプリケーションのデプロイ
　・サーバ群のオーケストレーション(自動配備・管理的な意味)
[DCT機能(Docker Content Trust)]
・作成したdockerイメージ用を署名し、なりすましを防ぐ。作成者はOfficeKey(秘密鍵)を作成し、
　利用者はTaggingKey(公開鍵)を使って検証を行う。
　DCT機能の有効化は以下の設定を行えば終わり。後は通常通り、pullすると自動で検証する。
　署名がついてないimageをpullするとエラーになる。
　　$export DOCKER_CONTENT_TRUST=1 (0で無効化)

[イメージ情報]
・ID:イメージに割り当てられる一意なID。ランダム生成される。
・Dockerバージョン：作成したDockerのバージョン。動かないときはとりあえずココ見る。
・タグ：イメージの目印となる名前。バージョン名にするのが一般的。
・アーキテクチャー：CPUのアーキテクチャ


[ネットワーク設定]
・Dockerではデフォルトで、ホストOSとブリッジ接続を行う。
 変更する場合は、コンテナ生成時に--netオプションを使って指定する。

[Dockerfile使い方]
1)インフラ構成要素の記述(通常であれば、インフラ設計書やパラメータシートに書く内容)
 ・ベースになるDockerイメージ
 ・Dockerコンテナ内で行った操作(コマンド)
 ・環境変数などの設定
 ・Dockerコンテナ内で動作させておくデーモン実行
2)Dockerfileの基本構文　： "命令 引数" ->この書式を羅列する。
  ①命令一覧
　・FROM	：ベースイメージの指定。FROM [イメージ名][:タグ名]
　・RUN　	：ビルド(イメージ生成)時に任意のコマンドを実行。要は、dockerエンジン上のLinuxコマンド？
		　ex.RUN [コマンド] 	
　・CMD　　　	：コンテナ実行時のコマンド。(docker run時に指定するような)
　・LABEL　　	：ラベルを設定。
　・EXPOSE　　	：ポートのエクスポート(解放)。
　・ENV　　　 　：環境変数。
　・ADD　　　	：ファイル/ディレクトリの追加。
　・COPY　　　	：ファイルのコピー。	COPY [host側ファイル] [イメージ側指定ディレクトリ]
　・ENTRYPOINT　：docker run時に実行されるコマンド。実行時にCLIから引数を受け取れる。ENTRYPOINT ["パス"]
　・VOLUME　　	：ボリュームのマウント。
　・USER　　　	：ユーザーの指定。
　・WORKDIR　	：作業ディレクトリを指定。ない場合は新しく生成する。 WORKDIR [パス]
　・ARG		:Dockerfile内の変数。
　・SHELL 	:デフォルトシェルの設定。
 ②コメント　
   #でその行はコメントとなる。
3)Dockerfileの作成フロー
　・FROMでベースイメージ指定
　・必要なミドルウェアをインストール、ユーザーやディレクトリを作成するコマンドの実行。
　・コンテナのデーモン起動
4)Dockerfileコマンドの実行
　RUN [実行したいコマンド]
　=>2通りの記述がある。
  ①Shell形式での記述
　　 RUN apt-get install -y nginx ※nginxのインストール
　　　=>シェルで実行する。使用するシェルは、Dockerfile内SHELL命令で指定。
　②Exec形式での記述
　　 RUN ["/bin/bash","-c","apt-get install -y nginx"]
      =>
4)$docker buildコマンドでDockerfileを元にイメージを生成する。


[複数コンテナの管理]
通常Webシステムの実行環境は、Webサーバ、プロキシ、DBなど複数のサーバが連携して動作する。
そのため、Dockerでも複数のコンテナを連携させ運用する事で、同じことを実現する。
1.Web３層アーキテクチャ
　アプリケーション稼動のために複数のサーバに機能や役割を分割してインフラ全体を構成するアーキテクチャ(設計思想)
　主に以下の3つに分けられる為、3層と呼ぶ。あくまで論理的な分割である為、１つの物理サーバに実現も可。
 1)フロントサーバ
　　クライアントのWebブラウザから送信されたHTTPリクエストを受け付けて、レスポンスを返すサーバ機能を持つ。
　一般的にWebサーバと呼ばれるもの。ミドルウェアで実現され、負荷に応じてロードバランサ等で負荷分散を行う。
 2)アプリケーションサーバ
　　業務処理を実行するサーバ。Webサーバ同様ミドルウェアで実現される。場合によっては、Webサーバとまとめることも
 3)DBサーバ
　　永続データの管理を行うサーバ。高い可用性が求められる為、クラスタリングやRAID構成で冗長化する。
　　DB操作処理は負荷がかかる為、システム全体のボトルネックになりやすい。よって、運用状況に応じて、OSやミドルウェア
　　のパラメータ設定変更などのパフォーマンスチューニングが必要。

2.docker-compose.yml書き方（※YAMLファイル：設定ファイルとかに使われるデータフォーマット)
[基礎]
・pythonのようにスペースインデントで階層分けする。(tabインデントはダメ)
・文字の先頭に-(ハイフン)をつけると、配列となる。(ハイフンの後は半角スペース入れる)
[compose設定項目]
・version: '3.3'  =>バージョンを指定する。ymlファイルのﾙｰﾄ。
・services:   => ﾙｰﾄ直下。このservicesの子要素に各コンテナ定義を書く。
・コンテナ名:	=>コンテナの名称。コンテナごとにつくる。
・image: 	=>コンテナ生成に使用するイメージを指定。ローカルになければDockerHubからDL。
・build: Dockerfileのパス =>Dockerfileが作成されていれば、それを使用。   
・ports: 
   - "3000:3000"  =>ポートフォワード。Dockerfileでも指定していた場合、yml指定に上書きされる。
・exports:
   - "3000"	=>ホストからアクセスはさせず、あくまでコンテナ間で利用する為のポート開放。
・volumes: 
   - ./workspace:/wordspace  =>ボリュームのマウント。ホスト：コンテナ。
・depends_on: 
   - mysql	=>別コンテナとの依存指定。書いた順番に起動する。
・links:
   -mysql 	=>別コンテナへリンク機能を使って接続できるようにする。
		　コンテナからアクセスする際は、ホスト名をここで指定した名称にする。
		　ポートは別途、対象コンテナで指定したポートを使用。
・stdin_open: true =>docker run -it に相当。コンテナ起動後終了させない為。
　tty: true
・command: /bin/bash	=>コンテナ起動時に実行するコマンド。Dockerfileで指定していた場合、yml側が反映される。

****************************************************************************************************

(ex.Go言語とbusyboxイメージを生成する)
	#1.BuildImage
	FROM golang:1.8.4-jessie AS builder
	#Install dependencies
	WORKDIR /go/src/github.com/asashiho/greet
	RUN go get -d -v github.com/urfave/cli

	#Build modules
	COPY main.go .
	RUN GOOS=linux go build -a -o greet .
	#------------------------------------
	#2.Production Image
	FROM busybox
	WORKDIR /opt/greet/bin
	#Deploy modules
	COPY --from=builder /go/src/github.com/asashiho/greet/ .
	ENTRYPOINT ["./greet"]
 [解説]
 ①開発環境用のDockerイメージ
  ・Go言語ver1.8.4をベースイメージとし、workdirを作成しCLIパッケージをインストールする。
　　ホスト側"main.go"ファイルをコンテナ"."へコピーし、go buildコマンドでビルドし、
　　greetという実行可能バイナリファイルを作成する。
　　
 ②プロダクション環境用のDockerイメージ(busyboxは基本的なLinuxコマンド群を単一のファイルにまとめたもの)
　・busyboxをベースにworkdirを作る。--from=builderの通り、builderという名前のイメージからgreetファイルを
　　busyboxイメージへコピーする。
　　最後に、コピーした実行可能バイナリファイル"greet"を起動する。
