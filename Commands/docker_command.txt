■基本フロー
[構築1]*******************************************************************************
プロジェクト(ディレクトリ)作成し、cd。
Dockerfileの作成	=>コンテナの構成情報を定義したファイル。
			  ・FROM:ベースとするイメージを指定。
			　・WORKDIR:コンテナアタッチ後のカレントディレクトリ名を指定
			  ・CMD["指定"] : 
$docker build -t イメージ名 ディレクトリ名	=>コンテナイメージの生成。
						　Dockerfileとベースイメージが必要
$docker run -it --name コンテナ名

[構築2]-----------------------------------------------------------------------------
$docker pull イメージ名			=>リモートリポジトリからDockerイメージを入手
$docker images ls			=>ローカルのイメージ一覧を確認
$docker images inspect イメージ名	=>イメージの詳細を表示
$docker run -it --name コンテナ名 -p 127.0.0.1:8080:3030 -v ホスト側パス:コンテナ側パス	
					=>コマンドラインで操作できるコンテナを作成
					　ポートフォワードも忘れずに。
$docker exec コンテナ名			=>コンテナにログイン(アタッチ)する。
					 (-itでそのままコンソールから操作できる)
[実行]-------------------------------------------------------------------------------
$docker start コンテナ名
$docker exec -it コンテナ名 "/bin/bash"


***************************************************************************************
■コマンド一覧
[Docker管理コマンド]-------------------------------------------------------------------
$dockerd [オプション]
	=>Dockerコンテナを管理するDockerデーモン(サービス)の起動。
	Dockerはデーモンとクライアントで異なるバイナリを使うらしい。
	外部とやり取りさせる場合は、色々設定必要そう...
$docker inspect [オプション] コンテナ|イメージ|タスク[コンテナ|イメージ|タスク...]
	=>コンテナorイメージorタスクの低レベル情報をJSONで表示。
	要はコンテナの設定をJSON形式で表示する。なお、フォーマット指定も可。
$docker version [オプション]
	=>dockerのバージョン取得。
	<オプション>
	-f,--format=""	指定するgoテンプレートを使い、出力を整形。(text/templateパッケージ参照)
	--help		使い方表示


[イメージ用コマンド]-------------------------------------------------------------------
$docker build [オプション]　パス | URL
	=>パスにあるソースコードから新しいイメージを構築する。
	オプションは、ハードリソースに関するものが多め。
	<オプション>
	--no-cache=true	ビルド時にキャッシュを無効にする。デフォルトはこれがtrue。	
$docker images [イメージ名]
	=>イメージを一覧表示する。
	<オプション>
	-a,--all=false	全てのイメージを表示
	--digests=false	digest値を表示
	-f		指定した状況に応じて出力を整形
	etc...
$docker rmi [オプション] イメージ [イメージ...]
	=>1つ又は複数のイメージを削除


[コンテナ用コマンド]--------------------------------------------------------------------
$docker ps [オプション]
	=>コンテナの一覧表示
	<オプション>
	-a,--all	全てのコンテナを表示(デフォルトは実行中のコンテナのみ)
$docker run [オプション] イメージ [コマンド] [引数]
	=>新しいコンテナを実行する。(初期化とか?)
	<オプション>
	-h ホスト名		ホスト名を付けられる。
	--name コンテナ名	コンテナに名前を付けられる。
	-i  			起動時にSTDOUTを開きっぱなしにできる。		
	-t				
	他大量...
$docker exec [オプション]　コンテナ　コマンド [引数]
	=>実行中のコンテナでコマンドを実行。上記runでイメージ実行後であれば実行できる。
	<オプション>
	-d	"コマンド"をバックグラウンドで実行
	-i	アタッチしてなくてもSTDINをオープンし続ける
	-t	疑似ターミナル(pseudo-TTY)の割り当て	
$docker rm [オプション] コンテナ [コンテナ....]
	=>1つ又は複数のコンテナを削除
$docker start [オプション] コンテナID
	=>コンテナを起動する。
	<オプション>
	-a	コンテナを起動してログインする。(attachする)
$docker stop [オプション] コンテナID
	=>コンテナを停止する。
$docker restart	[オプション] コンテナID
	=>コンテナを再起動する。

$docker attach コンテナID
	=>起動中のコンテナにログインする。
	
$docker rename 古い名前 新しい名前
	=>コンテナの名前を変更

$docker kill [オプション] コンテナ [コンテナ...]
	=>実行中のコンテナをSIGKILLか、指定したシグナルで停止
	<オプション>
	-s,--signal="KILL"	コンテナに送信するシグナル。
				コンテナ中のメイン・プロセス(PID1)に対してシグナルを送る


[Hub/レジストリ用コマンド]------------------------------------------------------------
$docker pull [オプション] イメージ名[:タグ]|[レジストリ・ホスト[:レジストリ・ポート]/名前[:タグ]
	=>レジストリからイメージやリポジトリを取得する。
	"$docker pull イメージ名"で実行した場合、レジストリはDockerHubがデフォルトで指定される。
	プロキシ経由で利用する場合は、Dockerデーモンの設定(環境変数の設定)が必要。詳細はggr
$docker push [オプション] 名前[:タグ]
	=>イメージやリポジトリをレジストリに送信する。
$docker search [オプション] 単語
	=>DockerHubのイメージを検索
	

[ネットワーク接続用コマンド]----------------------------------------------------------
$docker network connect [オプション]　ネットワーク　コンテナ
	=>コンテナをネットワークに接続

[共有データ・ボリューム用コマンド]----------------------------------------------------
$docker volume create [オプション]
	=>ボリュームを作成。コンテナが利用し、データを保管するディレクトリ。
	オプションで名前指定しなければランダムな名前が付けられる。
	<オプション>
	--name=ボリューム名	ボリューム名を指定
	-d,--driver=local	ボリューム/ドライバ名を指定
$docker volume ls
	=>ボリュームの一覧